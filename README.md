# E2EE Instant Messaging

A secure instant messaging application built on the **Signal Protocol** (X3DH + Double Ratchet). The server routes encrypted ciphertext and never has access to plaintext messages.

## How it Works

### The Big Picture

```
Alice's Browser                  Server                  Bob's Browser
───────────────                ──────────              ──────────────────

1. Fetch Bob's public keys ──> /keys/bundle/{bob}
                           <── { identity_key, signed_prekey, one_time_prekey }

2. Run X3DH locally
   (derive shared secret)

3. Encrypt with Double Ratchet
   plaintext → ciphertext

4. Send via WebSocket ──────> store ciphertext
                              forward if online ──────> receive ciphertext

                                                        5. Decrypt locally
                                                           ciphertext → plaintext
```

The server only ever stores and forwards the encrypted ciphertext. Private keys never leave the device.

---

## Signal Protocol Implementation

### Phase 1 — X3DH (Session Setup)

X3DH (Extended Triple Diffie-Hellman) runs **once per new conversation** to establish a shared secret between two devices without any prior contact.

**Keys involved:**

| Key | Type | Purpose |
|-----|------|---------|
| Identity Key (IK) | X25519 | Long-term device identity |
| Signed PreKey (SPK) | X25519 | Medium-term, signed by Ed25519 key |
| One-Time PreKey (OPK) | X25519 | Single-use, consumed on first message |
| Ephemeral Key (EK) | X25519 | Per-session, generated by sender |

**How it runs:**

Bob uploads `SPK` and a batch of `OPK`s to the server when he registers his device. When Alice wants to message Bob for the first time:

1. Alice fetches Bob's key bundle: `IK_Bob`, `SPK_Bob`, `OPK_Bob` (one-time, consumed)
2. Alice verifies `SPK_Bob` is signed by Bob's Ed25519 identity signing key — if the signature is invalid, the session is rejected (MITM detection)
3. Alice generates an ephemeral key `EK_Alice` and computes four DH operations:
   ```
   DH1 = DH(IK_Alice, SPK_Bob)
   DH2 = DH(EK_Alice, IK_Bob)
   DH3 = DH(EK_Alice, SPK_Bob)
   DH4 = DH(EK_Alice, OPK_Bob)   ← only if OPK available
   ```
4. Shared secret: `SK = HKDF(DH1 || DH2 || DH3 || DH4)`
5. Both Alice and Bob derive identical `SK` independently — no secret is transmitted

The X3DH header (`IK_Alice`, `EK_Alice`, SPK/OPK IDs) is included in the first message so Bob can replicate the DH operations on his side.

### Phase 2 — Double Ratchet (Per-Message Encryption)

Once the X3DH shared secret is established, every subsequent message uses the Double Ratchet. The ratchet evolves the key material forward after every message, so compromising a key today does not expose past messages.

**Two ratchets running together:**

```
Symmetric Ratchet (fast, per-message):
  chain_key_n  ──HKDF──>  chain_key_{n+1}  +  message_key_n
                                               ↓
                                           encrypt/decrypt message n

DH Ratchet (slower, per reply):
  When Bob replies, he generates a new DH key pair.
  Both sides run DH and derive a new root key.
  This "breaks in" a completely fresh chain key.
```

Every message key is used exactly once and then discarded. If an attacker captures all keys at time T, they cannot decrypt messages from before T (forward secrecy) or after T (break-in recovery).

### Cryptographic Primitives

| Primitive | Algorithm | Used For |
|-----------|-----------|----------|
| Key Exchange | X25519 | DH operations in X3DH and Double Ratchet |
| Signatures | Ed25519 | Signing the Signed PreKey (MITM detection) |
| KDF | HKDF-SHA256 (Web Crypto API) | Root key, chain key, message key derivation |
| Encryption | XSalsa20-Poly1305 (TweetNaCl) | AEAD message encryption |
| Associated Data | DR header bytes | Bound into ciphertext; tampering detected |

---

## Architecture

```
E2EE_project/
├── server/                      # FastAPI backend
│   ├── main.py                  # HTTP endpoints + WebSocket handler
│   ├── models.py                # SQLAlchemy ORM (User, Device, Message, Keys)
│   ├── crud.py                  # DB helpers
│   ├── auth.py                  # JWT authentication (bcrypt + PyJWT)
│   ├── schemas.py               # Pydantic request/response schemas
│   ├── db.py                    # Async SQLite session factory
│   └── ws.py                    # WebSocket presence map
│
└── client/                      # React + Vite frontend
    └── src/
        ├── App.jsx              # App state, auth, device registration
        ├── e2ee/
        │   ├── signal-protocol.js   # X3DH + Double Ratchet (~600 lines)
        │   └── keystore.js          # localStorage key/session persistence
        ├── services/
        │   ├── api.js           # REST API calls (auth, devices, keys)
        │   └── websocket.js     # WebSocket client + encrypt/decrypt integration
        └── components/
            ├── Auth.jsx         # Login / Register
            ├── ChatList.jsx     # User list sidebar
            ├── ChatWindow.jsx   # Message thread
            └── MessageInput.jsx # Compose box
```

### Key Flow: First Message

```
Client boot
  └─ keyStore.getIdentityKey()  → load or generate X25519 identity key
  └─ keyStore.getSigningKey()   → load or generate Ed25519 signing key
  └─ keyStore.getSignedPreKey() → load or generate X25519 SPK
  └─ generate 10× one-time prekeys

POST /devices         { identity_key_public, identity_signing_public }
POST /keys/upload     { signed_prekey: { key_id, public_key, signature },
                        one_time_prekeys: [...] }

User selects recipient → GET /keys/bundle/{recipient_id}
  └─ X3DH runs locally → shared secret SK
  └─ DoubleRatchetSession.init(SK, bob_ratchet_key)
  └─ session saved to localStorage

sendEncrypted(plaintext)
  └─ session.encrypt(plaintext) → { header, ciphertext, nonce, ad_length }
  └─ WebSocket send { type:"send", to_device_id, header, ciphertext, ... }

Server: store → forward to recipient's WebSocket (or queue for offline)

Recipient receives { type:"deliver", ... }
  └─ signalProtocol.decryptFrom(senderDeviceId, message)
     └─ load session from localStorage
     └─ session.decrypt(message) → plaintext
```

### Key Flow: Subsequent Messages

No X3DH, no key bundle fetch. The session is loaded from localStorage and the Double Ratchet continues from where it left off.

---

## Database Schema

**users** — `id` (UUID), `username`, `password_hash`

**devices** — `id`, `user_id`, `device_name`, `identity_key_public` (X25519), `identity_signing_public` (Ed25519)

**signed_prekeys** — `device_id`, `key_id`, `public_key`, `signature`, `is_active`

**one_time_prekeys** — `device_id`, `key_id`, `public_key`, `consumed_at` (null = available)

**messages** — `message_id`, `from_device_id`, `to_device_id`, `header` (JSON), `ciphertext`, `nonce`, `ad_length`, `is_initial_message`, `x3dh_header` (JSON), `server_ts`, `delivered_ts`, `read_ts`

Messages are kept until delivered and acknowledged (ACK). The server never decrypts or inspects `ciphertext`.

---

## API

### HTTP

| Method | Endpoint | Description |
|--------|----------|-------------|
| POST | `/auth/register` | Create account, returns JWT |
| POST | `/auth/login` | Authenticate, returns JWT |
| GET | `/users` | List all users except self |
| DELETE | `/users/{id}` | Delete a user and all their data |
| POST | `/admin/reset` | Wipe all data (dev/admin tool) |
| GET | `/users/{id}/devices` | List devices for a user |
| POST | `/devices` | Register a new device |
| POST | `/keys/upload` | Upload SPK + batch of OPKs |
| GET | `/keys/bundle/{user_id}` | Fetch prekey bundle (consumes one OPK) |

### WebSocket

`WS /ws?token={jwt}&device_id={uuid}`

**Client → Server messages:**

```json
{ "type": "send", "to_device_id": "...", "message_id": "...",
  "header": {...}, "ciphertext": "...", "nonce": "...",
  "ad_length": 42, "is_initial_message": true, "x3dh_header": {...} }

{ "type": "ack_delivered", "message_id": "..." }
{ "type": "ack_read",      "message_id": "..." }
```

**Server → Client messages:**

```json
{ "type": "deliver", "from_device_id": "...", "from_user_id": "...",
  "message_id": "...", "header": {...}, "ciphertext": "...",
  "nonce": "...", "ad_length": 42, "is_initial_message": false,
  "x3dh_header": null, "server_ts": "2024-..." }
```

On connect, the server flushes any queued (undelivered) messages before entering the live message loop.

---

## Security Properties

**What the server can see:**
- Usernames, bcrypt-hashed passwords
- Device public keys (by design — needed for key distribution)
- Message metadata: from/to device IDs, timestamps
- Encrypted ciphertext (opaque byte strings)

**What the server cannot see:**
- Any message plaintext
- Private keys (never uploaded)
- Session keys or shared secrets (derived locally, stored in localStorage)

**Guarantees:**
- Forward secrecy — past messages safe if current keys leak
- Break-in recovery — DH ratchet re-randomizes keys on each reply round
- MITM detection — SPK signature verified with Ed25519 before X3DH proceeds
- AEAD integrity — header bytes are bound as associated data; modifying the header breaks decryption

**Limitations:**
- Keys are stored in browser localStorage — a compromised device exposes keys
- No group messaging (1:1 only)
- No key rotation for the long-term identity key

---

## Running Locally

### Prerequisites

- Python 3.10+
- Node.js 18+

### Backend

```bash
pip install -r requirements.txt
cd server
uvicorn main:app --reload --port 8000
```

### Frontend

```bash
cd client
npm install
npm run dev
```

Open `http://localhost:5173` (or whichever port Vite assigns).

### First Run

1. Register two users in separate browser windows
2. Send messages between them
3. Server logs show `ciphertext=mBd9...` — never plaintext
4. Browser console shows `[Signal] Loaded existing session` on subsequent messages

### Reset Everything

Use the trash icon button in the app sidebar (calls `POST /admin/reset`), then clear localStorage in both browser windows (DevTools → Application → Local Storage → Clear All) and re-register.

Or from the terminal:
```bash
sqlite3 securemsg.db "DELETE FROM messages; DELETE FROM one_time_prekeys; DELETE FROM signed_prekeys; DELETE FROM devices; DELETE FROM users;"
```

---

## References

- [Signal X3DH Specification](https://signal.org/docs/specifications/x3dh/)
- [Signal Double Ratchet Specification](https://signal.org/docs/specifications/doubleratchet/)
- [TweetNaCl-js](https://tweetnacl.js.org/)
- [Web Crypto API — HKDF](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveBits)
